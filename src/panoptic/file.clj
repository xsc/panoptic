(ns ^{:doc "File Representation"
      :author "Yannick Scherer"}
  panoptic.file
  (:require [clj-time.core :as t]
            [me.raynes.fs :as fs]
            [panoptic.utils :as u]))

;; ## File Map
;;
;; A file is represented as a map with only one mandatory field, namely `:path` containing
;; a fully-qualified path to a file. Additional data, used by Panoptic, includes:
;;
;; - `:checked`: unix timestamp of time the file was last checked for changes
;; - `:modified`/`:created`/`:deleted`: flags indicating the checking result
;; - `:checksum`: checksum value generated by a Panoptic checker (this might
;;    be anything comparable using `=`).

(defn file
  "Create new File Map using the given Path."
  [path]
  (-> {}
    (assoc :path (fs/absolute-path path))))

;; ## Panoptic Data

(let [E (t/epoch)]
  (defn- update-timestamp
    "Update `:checked` timestamp in File Map."
    [f] 
    (assoc f :checked (t/in-secs (t/interval  E (t/now))))))

(defn set-file-deleted
  "Set `:deleted` data in File Map, update timestamp and checksum."
  [f]
  (-> f
    (dissoc :created :modified :missing )
    (assoc :deleted true) 
    (dissoc :checksum)
    (update-timestamp)))

(defn set-file-created
  "Set `:created` data in File Map, update timestamp and checksum."
  [f checksum]
  (-> f
    (dissoc :deleted :modified :missing )
    (assoc :created true)
    (assoc :checksum checksum)
    (update-timestamp)))

(defn set-file-modified
  "Set `:modified` data in File Map, update timestamp and checksum."
  [f checksum]
  (-> f
    (dissoc :created :deleted :missing)
    (assoc :modified true)
    (assoc :checksum checksum)
    (update-timestamp)))

(defn set-file-missing
  [f]
  (-> f
    (dissoc :created :deleted :modified)
    (assoc :missing true)
    (update-timestamp)))

(defn set-file-untouched
  "Clear all `:deleted`, `:modified` and `:created` data in File Map, update timestamp."
  [f checksum]
  (-> f
    (dissoc :created :deleted :modified :missing)
    (assoc :checksum checksum)
    (update-timestamp)))

;; ## Directory Map

(defn- create-include-function
  [exclude precondition]
  (let [patterns (seq exclude)]
    (cond (not (or patterns precondition)) (constantly true)
          (and patterns precondition) #(and (precondition %) (not (u/match-some? patterns %)))
          (and (not patterns) precondition) precondition
          :else #(not (u/match-some? patterns %)))) )

(defn directory
  "Create directory map from directory path and additional options."
  [path & {:keys [extensions include-hidden exclude exclude-dirs exclude-files] :as opts}] 
  (let [f (fs/file path)
        include? (create-include-function exclude nil)
        include-file? (create-include-function exclude-files include?)
        include-dir? (create-include-function exclude-dirs include?)
        valid-extension? (if-not (seq extensions)
                           (constantly true)
                           (let [ext (set (map #(str "." (if (keyword? %) (name %) (str %))) extensions))]
                             #(contains? ext (fs/extension %))))]
    (when (and (fs/exists? f) (fs/directory? f))
      (let [path (fs/absolute-path f)
            children (fs/list-dir f)]
        (-> {}
          (assoc :path path)
          (assoc :opts opts)
          (assoc :files 
                 (->> children
                   (filter #(fs/file? (str path "/" %)))
                   (filter valid-extension?)
                   (filter include-file?)
                   (set)))
          (assoc :directories 
                 (->> children
                   (filter #(fs/directory? (str path "/" %)))
                   (filter #(or include-hidden (not (.startsWith ^String % "."))))
                   (filter include-dir?)
                   (set))))))))

(defn directories
  "Create seq of directories by recursively traversing the directory tree starting at
   the given root path."
  [root-path & opts]
  (when-let [{:keys [path] :as d} (apply directory root-path opts)] 
    (let [dirs (:directories d)] 
      (if-not (seq dirs)
        [d]
        (cons d (mapcat #(apply directories (str path "/" %) opts) dirs))))))

(defn set-directory-deleted
  "Set `:deleted` data in directory map."
  [dir]
  (-> dir
    (dissoc :created :modified)
    (assoc :deleted true)
    (update-timestamp)))
